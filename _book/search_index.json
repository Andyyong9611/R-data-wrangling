[
["tidyr.html", "Chapter 2 Data Manipulation using tidyr 2.1 About long and wide table format 2.2 Long to Wide with spread 2.3 Wide to long with gather 2.4 Exporting data", " Chapter 2 Data Manipulation using tidyr Learning Objectives Understand the concept of a wide and a long table format and for which purpose those formats are useful. Understand what key-value pairs are. Reshape a data frame from long to wide format and back with the spread and gather commands from the tidyr package. Export a data frame to a .csv file. dplyr pairs nicely with tidyr which enables you to swiftly convert between different data formats for plotting and analysis. The package tidyr addresses the common problem of wanting to reshape your data for plotting and use by different R functions. Sometimes we want data sets where we have one row per observation. Sometimes we want a data frame where each observation type has its own column, and rows are instead more aggregated groups - like surveys, where each column represents an answer. Moving back and forth between these formats is nontrivial, and tidyr gives you tools for this and more sophisticated data manipulation. To learn more about tidyr after the workshop, you may want to check out this cheatsheet about tidyr. 2.1 About long and wide table format The ‘long’ format is where: each column is a variable each row is an observation In the ‘long’ format, you usually have 1 column for the observed variable and the other columns are ID variables. For the ‘wide’ format each row is often a site/subject/patient and you have multiple observation variables containing the same type of data. These can be either repeated observations over time, or observation of multiple variables (or a mix of both). You may find data input may be simpler or some other applications may prefer the ‘wide’ format. However, many of R‘s functions have been designed assuming you have ’long’ format data. This tutorial will help you efficiently transform your data regardless of original format. Figure 2.1: Wide vs. Long Table Format The choice of data format affects readability. For humans, the wide format is often more intuitive, since we can often see more of the data on the screen due to its shape. However, the long format is more machine readable and is closer to the formatting of databases. The ID variables in our dataframes are similar to the fields in a database and observed variables are like the database values. Challenge 1 Is trafficstops in a long or wide format? 2.2 Long to Wide with spread Now let’s see this in action. First, using dplyr, let’s create a data frame with the mean age of each driver by gender and county: trafficstops_ma &lt;- trafficstops %&gt;% filter(!is.na(driver_gender)) %&gt;% group_by(county_name, driver_gender) %&gt;% summarize(mean_age = mean(driver_age, na.rm = TRUE)) head(trafficstops_ma) #&gt; # A tibble: 6 x 3 #&gt; # Groups: county_name [3] #&gt; county_name driver_gender mean_age #&gt; &lt;fctr&gt; &lt;fctr&gt; &lt;dbl&gt; #&gt; 1 Adams County female 36.73176 #&gt; 2 Adams County male 38.39265 #&gt; 3 Alcorn County female 33.28516 #&gt; 4 Alcorn County male 34.06153 #&gt; 5 Amite County female 38.29559 #&gt; 6 Amite County male 40.27757 Now, to make this long data wide, we use spread from tidyr to spread out the driver gender into columns. spread takes three arguments - the data, the key column, or column with identifying information, the values column - the one with the numbers. We’ll use a pipe so we can ignore the data argument. trafficstops_ma_wide &lt;- trafficstops_ma %&gt;% spread(driver_gender, mean_age) head(trafficstops_ma_wide) #&gt; # A tibble: 6 x 3 #&gt; # Groups: county_name [6] #&gt; county_name female male #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Adams County 36.73176 38.39265 #&gt; 2 Alcorn County 33.28516 34.06153 #&gt; 3 Amite County 38.29559 40.27757 #&gt; 4 Attala County 36.66609 38.12115 #&gt; 5 Benton County 32.07792 34.36496 #&gt; 6 Bolivar County 33.19608 36.26228 We can now do things like compare the mean age of men against women drivers. As example we use the age difference to find the counties with the largest and with the smallest number. (A negative number means that female drivers are on average older than male drivers, a positive number means that male drivers are on average older than women drivers.) trafficstops_ma_wide %&gt;% mutate(agediff = male - female) %&gt;% ungroup() %&gt;% filter(agediff %in% range(agediff)) #&gt; # A tibble: 2 x 4 #&gt; county_name female male agediff #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Neshoba County 35.08824 31.14634 -3.941894 #&gt; 2 Yalobusha County 33.42958 39.42222 5.992645 Note that trafficstops_ma_wide is derived from trafficstops_ma, and is a “grouped” data frame, which was created with the group_by function above. (Check class(trafficstops_ma) and class(trafficstops_ma_wide)). That means that any instruction that follows will operate on each group (in this case county) separately. That may be ok for some instances (like mutate), but if we are interested in retreiveing the max and the min age difference over all counties we need to ungroup the tibble to have the filter command operate on the entire dataset. 2.3 Wide to long with gather What if we had the opposite problem, and wanted to go from a wide to long format? For that, we use gather to sweep up a set of columns into one key-value pair. We give it the arguments of a new key and value column name, and then we specify which columns we either want or do not want gathered up. So, to go backwards from trafficstops_ma_wide, and exclude plot_id from the gathering, we would do the following: trafficstops_ma_long &lt;- trafficstops_ma_wide %&gt;% gather(gender, mean_age, -county_name) head(trafficstops_ma_long) #&gt; # A tibble: 6 x 3 #&gt; # Groups: county_name [6] #&gt; county_name gender mean_age #&gt; &lt;fctr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Adams County female 36.73176 #&gt; 2 Alcorn County female 33.28516 #&gt; 3 Amite County female 38.29559 #&gt; 4 Attala County female 36.66609 #&gt; 5 Benton County female 32.07792 #&gt; 6 Bolivar County female 33.19608 We could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. And if the columns are in a row, we don’t even need to list them all out – just use the : operator! trafficstops_ma_wide %&gt;% gather(gender, mean_age, female:male) %&gt;% head() #&gt; # A tibble: 6 x 3 #&gt; # Groups: county_name [6] #&gt; county_name gender mean_age #&gt; &lt;fctr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Adams County female 36.73176 #&gt; 2 Alcorn County female 33.28516 #&gt; 3 Amite County female 38.29559 #&gt; 4 Attala County female 36.66609 #&gt; 5 Benton County female 32.07792 #&gt; 6 Bolivar County female 33.19608 Challenge Make a wide data frame with year as columns, violation_raw as rows, and the values are the number of traffic stops per each violation. Use year() from the lubridate package. You will need to summarize before reshaping Now take that data frame, and make it long again, so each row is a unique violation_raw year combination. #> Attaching package: 'lubridate' ``` ``` #> The following object is masked from 'package:base': #> #> date ``` ---> Now that you have those commands under your belt, let’s go back to our table from before and reshape it so we can easily calculate the percentage of black and white. To clean things up a little, we remove rows where driver race is unknown. We then make sure that we count our NAs as 0. We know from earlier that in Tunica County all reported stops are for black drivers (Check again with: trafficstops %&gt;% filter(county_name == &quot;Tunica County&quot;)). By default spread would set the value for white stops to NA. Sometimes it is fine to leave those as NA. Sometimes we want to fill them as zeros, in which case we would add the argument fill = 0. In our case we prefer to count this a 0. Lastly, we introduce a separator (sep) as parameter to the spread command. If sep is not NULL, the column names will be given by &quot;&lt;key_name&gt;&lt;sep&gt;&lt;key_value&gt;&quot; and make them more explicit, easier for you to interpret, and for anyone who might use your data. trafficstops %&gt;% filter(!is.na(driver_race)) %&gt;% count(county_name, county_fips, driver_race) %&gt;% spread(driver_race, n, fill = 0, sep = &quot;_&quot;) %&gt;% head() Now we can pipe this into our left join and calculate the percentages: # make sure you have the other table loaded MS_bw_pop &lt;- read.csv(&quot;data/MS_acs2015_bw.csv&quot;) trafficstops %&gt;% filter(!is.na(driver_race)) %&gt;% count(county_name, county_fips, driver_race) %&gt;% spread(driver_race, n, fill = 0, sep = &quot;_&quot;) %&gt;% left_join(MS_bw_pop, by = c(&quot;county_fips&quot; = &quot;FIPS&quot;)) %&gt;% mutate(pct_black = driver_race_Black/black_pop, pct_white = driver_race_White/white_pop) %&gt;% print(n=5, width=Inf) #&gt; # A tibble: 82 x 8 #&gt; county_name county_fips driver_race_Black driver_race_White black_pop white_pop pct_black pct_white #&gt; &lt;fctr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Adams County 28001 583 359 17757 12856 0.03283212 0.02792470 #&gt; 2 Alcorn County 28003 468 2877 4281 31563 0.10932025 0.09115103 #&gt; 3 Amite County 28005 1589 1331 5416 7395 0.29338996 0.17998648 #&gt; 4 Attala County 28007 2096 2107 8194 10649 0.25579692 0.19785895 #&gt; 5 Benton County 28009 121 93 3078 5166 0.03931124 0.01800232 #&gt; # ... with 77 more rows Terrific. Now let’s use some visualization to help us understand our data. Before we do this though, let’s save this table out. 2.4 Exporting data Instead of printing the above output to the screen we will pipe it into another command. Similar to the read.csv() function used for reading CSV files into R, there is a write.csv() function that generates CSV files from data frames. Before using write.csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them. We can save the table generated by the join as a CSV file in our data_output folder. By default, write.csv() includes a column with row names (in our case the names are just the row numbers), so we need to add row.names = FALSE so they are not included: trafficstops %&gt;% filter(!is.na(driver_race)) %&gt;% count(county_name, county_fips, driver_race) %&gt;% spread(driver_race, n, fill = 0, sep = &quot;_&quot;) %&gt;% left_join(MS_bw_pop, by = c(&quot;county_fips&quot; = &quot;FIPS&quot;)) %&gt;% mutate(pct_black_stopped = driver_race_Black/black_pop, pct_white_stopped = driver_race_White/white_pop) %&gt;% write.csv(file = &quot;data_output/MS_demographic.csv&quot;, row.names = FALSE) "]
]
